//=========================================================================
//
//  This file was generated by Mouse 1.7 at 2015-09-15 15:19:19 GMT
//  from grammar
//    '/home/bpdp/kerjaan/git-repos/vastix/jifa/src/test/grammar/JifaGramma
//    r.peg'.
//
//=========================================================================

import mouse.runtime.Source;

public class JifaParser extends mouse.runtime.ParserBase
{
  final JifaSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public JifaParser()
    {
      sem = new JifaSemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = Input();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public JifaSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Input = [\n\r]* Line EOF ;
  //=====================================================================
  private boolean Input()
    {
      begin("Input");
      while (nextIn("\n\r"));
      if (!Line()) return reject();
      if (!EOF()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Line = Force Space Propositional+ {lineProcessed} ;
  //=====================================================================
  private boolean Line()
    {
      begin("Line");
      if (!Force()) return reject();
      if (!Space()) return reject();
      if (!Propositional()) return reject();
      while (Propositional());
      sem.lineProcessed();
      return accept();
    }
  
  //=====================================================================
  //  Force = Representatives / Directives / Commissives / Expressives /
  //    Declaratives ;
  //=====================================================================
  private boolean Force()
    {
      begin("Force");
      if (Representatives()) return accept();
      if (Directives()) return accept();
      if (Commissives()) return accept();
      if (Expressives()) return accept();
      if (Declaratives()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Representatives = "ASSERT" / "INFORM" ;
  //=====================================================================
  private boolean Representatives()
    {
      begin("Representatives");
      if (next("ASSERT")) return accept();
      if (next("INFORM")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Directives = "REQUEST" ;
  //=====================================================================
  private boolean Directives()
    {
      begin("Directives");
      if (!next("REQUEST")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Commissives = "CONSENT" ;
  //=====================================================================
  private boolean Commissives()
    {
      begin("Commissives");
      if (!next("CONSENT")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Expressives = "APOLOGIZE" / "THANK" / "COMPLAIN" ;
  //=====================================================================
  private boolean Expressives()
    {
      begin("Expressives");
      if (next("APOLOGIZE")) return accept();
      if (next("THANK")) return accept();
      if (next("COMPLAIN")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Declaratives = "DECLARE" ;
  //=====================================================================
  private boolean Declaratives()
    {
      begin("Declaratives");
      if (!next("DECLARE")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Propositional = StringLiteral {getPropositional} ;
  //=====================================================================
  private boolean Propositional()
    {
      begin("Propositional");
      if (!StringLiteral()) return reject();
      sem.getPropositional();
      return accept();
    }
  
  //=====================================================================
  //  StringLiteral = """ (Escape / !["\\n\r] _)* """ ;
  //=====================================================================
  private boolean StringLiteral()
    {
      begin("StringLiteral");
      if (!next('"')) return reject();
      while (StringLiteral_0());
      if (!next('"')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_0 = Escape / !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_0()
    {
      begin("");
      if (Escape()) return acceptInner();
      if (StringLiteral_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_1 = !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_1()
    {
      begin("");
      if (!aheadNotIn("\"\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Escape = "\" ([btnfr"'\] / OctalEscape / UnicodeEscape) ;
  //=====================================================================
  private boolean Escape()
    {
      begin("Escape");
      if (!next('\\')) return reject();
      if (!nextIn("btnfr\"'\\")
       && !OctalEscape()
       && !UnicodeEscape()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OctalEscape = [0-3] [0-7] [0-7] / [0-7] [0-7] / [0-7] ;
  //=====================================================================
  private boolean OctalEscape()
    {
      begin("OctalEscape");
      if (OctalEscape_0()) return accept();
      if (OctalEscape_1()) return accept();
      if (nextIn('0','7')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_0 = [0-3] [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_0()
    {
      begin("");
      if (!nextIn('0','3')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_1 = [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_1()
    {
      begin("");
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnicodeEscape = "u"+ HexDigit HexDigit HexDigit HexDigit ;
  //=====================================================================
  private boolean UnicodeEscape()
    {
      begin("UnicodeEscape");
      if (!next('u')) return reject();
      while (next('u'));
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  HexDigit = [a-f] / [A-F] / [0-9] ;
  //=====================================================================
  private boolean HexDigit()
    {
      begin("HexDigit");
      if (nextIn('a','f')) return accept();
      if (nextIn('A','F')) return accept();
      if (nextIn('0','9')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Space = " " / "\t" / "f" / EOL ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      if (next(' ')) return accept();
      if (next('\t')) return accept();
      if (next('f')) return accept();
      if (EOL()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  EOL = "\r" / "\n" ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL");
      if (next('\r')) return accept();
      if (next('\n')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  EOF = !_ <end of file> ;
  //=====================================================================
  private boolean EOF()
    {
      begin("EOF","end of file");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
