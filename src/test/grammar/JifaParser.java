//=========================================================================
//
//  This file was generated by Mouse 1.7 at 2015-09-09 04:51:40 GMT
//  from grammar
//    '/home/bpdp/kerjaan/git-repos/vastix/jifa/src/test/grammar/JifaGramma
//    r.peg'.
//
//=========================================================================

import mouse.runtime.Source;

public class JifaParser extends mouse.runtime.ParserBase
{
  final JifaSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public JifaParser()
    {
      sem = new JifaSemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = Input();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public JifaSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Input = [\n\r]* Line EOF ;
  //=====================================================================
  private boolean Input()
    {
      begin("Input");
      while (nextIn("\n\r"));
      if (!Line()) return reject();
      if (!EOF()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Line = Force Space Propositional+ {lineProcessed} ;
  //=====================================================================
  private boolean Line()
    {
      begin("Line");
      if (!Force()) return reject();
      if (!Space()) return reject();
      if (!Propositional()) return reject();
      while (Propositional());
      sem.lineProcessed();
      return accept();
    }
  
  //=====================================================================
  //  Force = Representatives / Directives / Commissives / Expressives /
  //    Declaratives ;
  //=====================================================================
  private boolean Force()
    {
      begin("Force");
      if (Representatives()) return accept();
      if (Directives()) return accept();
      if (Commissives()) return accept();
      if (Expressives()) return accept();
      if (Declaratives()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Representatives = "ASSERT" / "INFORM" ;
  //=====================================================================
  private boolean Representatives()
    {
      begin("Representatives");
      if (next("ASSERT")) return accept();
      if (next("INFORM")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Directives = "REQUEST" ;
  //=====================================================================
  private boolean Directives()
    {
      begin("Directives");
      if (!next("REQUEST")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Commissives = "CONSENT" ;
  //=====================================================================
  private boolean Commissives()
    {
      begin("Commissives");
      if (!next("CONSENT")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Expressives = "APOLOGIZE" / "THANK" / "COMPLAIN" ;
  //=====================================================================
  private boolean Expressives()
    {
      begin("Expressives");
      if (next("APOLOGIZE")) return accept();
      if (next("THANK")) return accept();
      if (next("COMPLAIN")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Declaratives = "DECLARE" ;
  //=====================================================================
  private boolean Declaratives()
    {
      begin("Declaratives");
      if (!next("DECLARE")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Propositional = (Space / Lcase / Ucase / Digits / Symbols)+
  //    {getPropositional} ;
  //=====================================================================
  private boolean Propositional()
    {
      begin("Propositional");
      if (!Propositional_0()) return reject();
      while (Propositional_0());
      sem.getPropositional();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Propositional_0 = Space / Lcase / Ucase / Digits / Symbols
  //-------------------------------------------------------------------
  private boolean Propositional_0()
    {
      begin("");
      if (Space()) return acceptInner();
      if (Lcase()) return acceptInner();
      if (Ucase()) return acceptInner();
      if (Digits()) return acceptInner();
      if (Symbols()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Space = " " / "\t" / "f" / EOL ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      if (next(' ')) return accept();
      if (next('\t')) return accept();
      if (next('f')) return accept();
      if (EOL()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Symbols = "~" / "!" / "@" / "#" / "$" / "%" / "^" / "&" / "*" / "("
  //    / ")" / "_" / "+" / "\" / "]" / "[" / "{" / "}" / "|" / ":" / """
  //    / ";" / "'" / "," / "." / "/" / "<" / ">" / "?" ;
  //=====================================================================
  private boolean Symbols()
    {
      begin("Symbols");
      if (next('~')) return accept();
      if (next('!')) return accept();
      if (next('@')) return accept();
      if (next('#')) return accept();
      if (next('$')) return accept();
      if (next('%')) return accept();
      if (next('^')) return accept();
      if (next('&')) return accept();
      if (next('*')) return accept();
      if (next('(')) return accept();
      if (next(')')) return accept();
      if (next('_')) return accept();
      if (next('+')) return accept();
      if (next('\\')) return accept();
      if (next(']')) return accept();
      if (next('[')) return accept();
      if (next('{')) return accept();
      if (next('}')) return accept();
      if (next('|')) return accept();
      if (next(':')) return accept();
      if (next('"')) return accept();
      if (next(';')) return accept();
      if (next('\'')) return accept();
      if (next(',')) return accept();
      if (next('.')) return accept();
      if (next('/')) return accept();
      if (next('<')) return accept();
      if (next('>')) return accept();
      if (next('?')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Lcase = [a-z]+ ;
  //=====================================================================
  private boolean Lcase()
    {
      begin("Lcase");
      if (!nextIn('a','z')) return reject();
      while (nextIn('a','z'));
      return accept();
    }
  
  //=====================================================================
  //  Ucase = [A-Z]+ ;
  //=====================================================================
  private boolean Ucase()
    {
      begin("Ucase");
      if (!nextIn('A','Z')) return reject();
      while (nextIn('A','Z'));
      return accept();
    }
  
  //=====================================================================
  //  Digits = [0-9]+ ;
  //=====================================================================
  private boolean Digits()
    {
      begin("Digits");
      if (!nextIn('0','9')) return reject();
      while (nextIn('0','9'));
      return accept();
    }
  
  //=====================================================================
  //  EOL = "\r" / "\n" ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL");
      if (next('\r')) return accept();
      if (next('\n')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  EOF = !_ <end of file> ;
  //=====================================================================
  private boolean EOF()
    {
      begin("EOF","end of file");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
